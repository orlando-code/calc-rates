```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(metafor) # need version 3.0 or higher (else 'regplot' function missing)
library(tidyverse)
library(MASS)
library(viridis)
library(patchwork)
library(magick)
library(ggsci)
library(ggpubr)
library(tidync)
library(lubridate)
library(rsvg)
library(svglite)

```

```{r ggplot settings}
# set general theme for figures
theme_cca <- function() {
  theme_classic(base_size = 12) +
    theme(
      panel.border = element_rect(colour = "black", fill = NA, linetype = 1),
      panel.background = element_rect(fill = "transparent"),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.line = element_blank(),
      plot.title = element_text(face = "italic"),
      axis.text = element_text(colour = "black"),
      axis.ticks = element_line(colour = "black"),
      legend.position = c(0.1,0.925),
      legend.text.align = 0, 
      legend.background = element_blank(), 
      legend.spacing = unit(0, "lines"), 
      legend.key = element_blank(), 
      legend.spacing.y = unit(0.25, 'cm'),
      legend.title = element_blank()
    ) 
}

colour.scheme <- c("black",
                   pal_npg(palette = c("nrc"), alpha = 1)(10)[4],
                   pal_npg(palette = c("nrc"), alpha = 0.6)(10)[10],
                   pal_npg(palette = c("nrc"), alpha = 0.6)(10)[1]
)

# ensure output directory present in same directory as script (for saving figures)
dir.create("output", showWarnings = FALSE)
```

```{r}
# calculate the cooks distance threshold via 2âˆš((k+1)/(n - k - 1))
threshold <- function(data, mods_formula) {
  # Extract the formula term count from the model used in run_meta_analysis
  k <- length(all.vars(mods_formula))-1 # k is number of parameters in model (doesn't include the intercept removal term)
  n <- nrow(data)
  return(2 * sqrt((k + 1) / (n - k - 1))) # Ben's formula: have found various online: including some which suggest just looking at the graph
}
```
```{r}
run_meta_analysis <- function(data, mods_formula, threshold_val = NULL, parallel_opts = list(type = "multicore", ncpus = 8)) {
  # Eliminates anomalies based on Cook's distance, then runs a random-effects multi-level model.
  model <- rma.mv(yi = hedges_g,
                 V = hedges_g_var,
                 data = data,
                 method = "REML",
                 mods = mods_formula,
                 test = "z",
                 random = list(~ 1 | (ID/original_doi)) # IDs are nested within original_doi
  )
  
  # calculate Cook's distance
  cooks_dist <- cooks.distance.rma.mv(
    model, 
    progbar = TRUE,
    reestimate = TRUE, 
    parallel = parallel_opts$type, 
    ncpus = parallel_opts$ncpus, 
    cl = NULL
  )
  
  # plot Cook's distances
  plot(cooks_dist, type = "o", pch = 19, 
       xlab = "ID", ylab = "Cook's Distance", xaxt = "n")
  
  axis(side = 1, at = seq_along(cooks_dist), 
       labels = as.numeric(names(cooks_dist)))
  
  # if threshold in argument is NULL, compute
  if (is.null(threshold_val)) {
    threshold_val <- threshold(data, mods_formula)
  }
  # threshold <- 
  cat(sprintf("Cook's distance threshold: %.2f\n", threshold_val))
  # determine outliers
  outliers <- cooks_dist %>% 
    as_tibble() %>% 
    mutate(ID = seq_len(nrow(data))) %>%
    filter(value > threshold_val)
  
  # Remove outliers if any were found
  cleaned_data <- data
  if (nrow(outliers) > 0) {
    cleaned_data <- data[-c(outliers$ID), ]
    cat(sprintf("Removed %d outliers\n", nrow(outliers)))
  } else {
    cat("No outliers detected\n")
  }
  
  # Re-run model with cleaned data
  final_model <- rma.mv(yi = hedges_g,
                      V = hedges_g_var,
                      data = cleaned_data,
                      method = "REML",
                      mods = mods_formula,
                      test = "z",
                      random = list(~ 1 | (original_doi/ID))
  )
  
  return(list(
    model = final_model,
    data = cleaned_data,
    outliers = outliers,
    cooks_dist = cooks_dist
  ))
}
```

```{r}
t_in_data_hedges <- read.csv(file="data/tmp/results_t_in.csv")
n_samples <- nrow(t_in_data_hedges)
# remove rows with nan values in necessary columns
necessary_cols <- c("hedges_g", "hedges_g_var", "delta_t", "t_in", "genus")
# data cleaning
t_in_data_hedges <- t_in_data_hedges %>% drop_na(necessary_cols)
print(n_samples - nrow(t_in_data_hedges)) # print how many rows were dropped


# run model for univariate analysis of temperature
t_in_results <- run_meta_analysis(
  data = t_in_data_hedges,
  mods_formula = ~ delta_t + t_in + factor(genus) - 1 # -ve 1 removes the model intercept
)

t_in_model <- t_in_results$model
t_in_data_hedges <- t_in_results$data # cleaned data
```


```{r, fig.width = 6, fig.height = 8}

# Overall plot of all studies assessing calcification in wrt temperature

svg(file = 'output/t_in_overall_bubble_with_id_nested.svg', width = 8, height = 8)

regplot.rma(t_in_model, mod = "delta_t", refline = 0, 
  # xlim = c(-1,0.25), ylim = c(-15,15), predlim = c(-1,0.25),
            ylab = "Hedges' g", xlab = expression(paste("\U0394", "Temperature")))
dev.off() 
```


```{r}
phtot_hedges <- read.csv(file="data/tmp/results_phtot.csv")
n_samples <- nrow(phtot_hedges)
# remove rows with nan values in necessary columns
necessary_cols <- c("hedges_g", "hedges_g_var", "delta_pH", "phtot", "genus")
# data cleaning
phtot_hedges <- phtot_hedges %>% drop_na(necessary_cols)
print(n_samples - nrow(phtot_hedges)) # print how many rows were dropped


mods_formula = ~ delta_pH + phtot - 1 # -ve 1 removes the model intercept
# run model for univariate analysis of temperature
phtot_results <- run_meta_analysis(
  data = phtot_hedges,
  mods_formula = mods_formula
)

phtot_model <- phtot_results$model
phtot_hedges <- phtot_results$data # cleaned data
```


```{r, fig.width = 6, fig.height = 8}

# Overall plot of all studies assessing calcification in wrt ph

svg(file = 'output/phtot_overall_bubble_with_id_nested2.svg', width = 8, height = 8)

regplot.rma(phtot_model, mod = "delta_pH", refline = 0, 
  # xlim = c(-1,0.25), ylim = c(-15,15), predlim = c(-1,0.25),
            ylab = "Hedges' g", xlab = expression(paste("\U0394", "pH")[T]),
            main = bquote(.(as.character(mods_formula)))
      )
      dev.off() 
```